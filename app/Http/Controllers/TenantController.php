<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Enums\TenantModule;
use App\Enums\TenantStatus;
use App\Enums\TenantType;
use App\Http\Requests\StoreTenantRequest;
use App\Http\Requests\TransitionTenantStatusRequest;
use App\Http\Requests\UpdateTenantRequest;
use App\Models\Tenant;
use App\Services\SubdomainGenerator;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\View\View;

/**
 * TenantController — Central Administration
 *
 * Manages the full tenant lifecycle from the super-admin domain.
 *
 * Subdomain provisioning
 * ──────────────────────
 *  Subdomains are auto-generated by SubdomainGenerator::generate() using the
 *  organisation name.  Admins never type a domain — the generator:
 *    1. Produces a slug-based FQDN (e.g. "fayiloli.ng")
 *    2. Checks the reserved-name blacklist and prefixes 'org-' when needed
 *    3. Queries the domains table and appends a numeric suffix (-2, -3 …) on collision
 *    4. Is environment-aware (local / staging / production) via tenancy config
 *
 * Provisioning idempotency contract
 * ──────────────────────────────────
 *  create() generates a UUID "provision key" stored in the session.
 *  store()  validates the key (via StoreTenantRequest::after()), then
 *           immediately CONSUMES it before calling Tenant::create().
 *  On success the key is gone — a browser-back + resubmit hits an empty
 *  session slot → StoreTenantRequest rejects it → the controller's
 *  secondary guard redirects the admin back to the create form.
 *
 * Status changes are gated by the TenantStatus state machine.
 * Authorization is delegated to TenantPolicy via authorizeResource().
 */
class TenantController extends Controller
{
    public function __construct(
        private readonly SubdomainGenerator $subdomainGenerator,
    ) {
        $this->authorizeResource(Tenant::class, 'tenant');
    }

    // ── List ──────────────────────────────────────────────────────────────────

    public function index(): View
    {
        $tenants = Tenant::with('domains')
            ->orderBy('created_at', 'desc')
            ->paginate(20);

        $stats = [
            'total'     => Tenant::count(),
            'active'    => Tenant::where('status', TenantStatus::ACTIVE)->count(),
            'pending'   => Tenant::where('status', TenantStatus::PENDING)->count(),
            'suspended' => Tenant::where('status', TenantStatus::SUSPENDED)->count(),
            'inactive'  => Tenant::where('status', TenantStatus::INACTIVE)->count(),
        ];

        return view('tenants.index', compact('tenants', 'stats'));
    }

    // ── Create ────────────────────────────────────────────────────────────────

    public function create(): View
    {
        // Generate a fresh idempotency key for this page load.
        // Stored in the session; embedded as a hidden field in the form so
        // StoreTenantRequest can verify it before provisioning executes.
        $provisionKey = (string) Str::uuid();
        session(['tenant_provision_key' => $provisionKey]);

        return view('tenants.create', [
            'tenantTypes'    => TenantType::cases(),
            'tenantModules'  => TenantModule::cases(),
            'defaultModules' => TenantModule::defaults(),
            'provisionKey'   => $provisionKey,
            // Domain suffix for the live JS preview widget.
            // e.g. ".localhost" | ".staging.fayiloli.ng" | ".fayiloli.ng"
            'domainSuffix'   => $this->subdomainGenerator->domainSuffix(),
        ]);
    }

    public function store(StoreTenantRequest $request): RedirectResponse
    {
        // ── Belt-and-suspenders key check ─────────────────────────────────
        // StoreTenantRequest::after() already rejects mismatched keys at the
        // validation layer.  This guard covers the rare race where session
        // state changes between FormRequest evaluation and controller entry
        // (e.g. two concurrent tab submissions).
        $submittedKey = $request->input('_provision_key');
        $sessionKey   = session('tenant_provision_key');

        if (! $sessionKey || $submittedKey !== $sessionKey) {
            return redirect()->route('tenants.create')
                ->with('warning', 'Your provisioning session expired or the form was already submitted. Please fill in the details again.')
                ->withInput($request->except('_provision_key'));
        }

        // ── Consume the key BEFORE any DB write ───────────────────────────
        // After this line the key is gone. Any subsequent submission (same
        // browser tab, parallel tab, or replayed request) will be rejected.
        session()->forget('tenant_provision_key');

        $data = $request->validated();

        // ── Auto-generate the primary subdomain ───────────────────────────
        // SubdomainGenerator uses short_name as the slug seed — a clean
        // 2–30 char abbreviation chosen by the admin (e.g. 'fmof', 'nhra').
        // It handles reserved-word blacklisting, collision detection, and
        // environment-aware FQDN construction (local/staging/production).
        $subdomain = $this->subdomainGenerator->generate($data['short_name']);

        // ── Provision ─────────────────────────────────────────────────────
        $modules = $data['modules'] ?? TenantModule::defaults();

        $tenant = Tenant::create([
            'organization_name' => $data['organization_name'],
            'short_name'        => $data['short_name'],
            'admin_email'       => $data['admin_email'],
            'tenant_type'       => $data['tenant_type'],
            'status'            => TenantStatus::PENDING,
            'notes'             => $data['notes'] ?? null,
            'settings'          => ['modules' => $modules],
        ]);

        // Attach the primary domain — fires DomainCreated event.
        // stancl/tenancy's HasDomains trait; the unique DB constraint on
        // domains.domain is the final atomic guard against race conditions.
        $tenant->domains()->create(['domain' => $subdomain]);

        // Provisioning is synchronous (shouldBeQueued = false) so the tenant
        // DB is ready — immediately activate.
        $tenant->transitionStatus(TenantStatus::ACTIVE);

        return redirect()
            ->route('tenants.show', $tenant)
            ->with('success', "Tenant \"{$tenant->organization_name}\" provisioned at {$subdomain} and activated.");
    }

    // ── Show ──────────────────────────────────────────────────────────────────

    public function show(Tenant $tenant): View
    {
        $tenant->load('domains');

        return view('tenants.show', [
            'tenant'        => $tenant,
            'transitions'   => $tenant->status?->allowedTransitions() ?? [],
            'tenantModules' => TenantModule::cases(),
        ]);
    }

    // ── Edit ──────────────────────────────────────────────────────────────────

    public function edit(Tenant $tenant): View
    {
        $tenant->load('domains');

        return view('tenants.edit', [
            'tenant'        => $tenant,
            'tenantTypes'   => TenantType::cases(),
            'tenantModules' => TenantModule::cases(),
        ]);
    }

    public function update(UpdateTenantRequest $request, Tenant $tenant): RedirectResponse
    {
        $data     = $request->validated();
        $modules  = $data['modules'] ?? [];
        $settings = array_merge($tenant->settings ?? [], ['modules' => $modules]);

        $tenant->update([
            'organization_name' => $data['organization_name'],
            'short_name'        => $data['short_name'],
            'admin_email'       => $data['admin_email'],
            'tenant_type'       => $data['tenant_type'],
            'notes'             => $data['notes'] ?? null,
            'settings'          => $settings,
        ]);

        return redirect()
            ->route('tenants.show', $tenant)
            ->with('success', 'Tenant details updated.');
    }

    // ── Destroy ───────────────────────────────────────────────────────────────

    /**
     * Permanently delete a tenant and drop its database — super-admin only.
     *
     * Three independent guards must ALL pass before the database is touched:
     *
     *   Gate 1 — Route middleware 'super-admin' (EnsureSuperAdmin)
     *     Resolves before this controller is instantiated.  Non-super-admins
     *     receive a 403 at the routing layer, never reaching this method.
     *
     *   Gate 2 — authorizeResource() via TenantPolicy::delete()
     *     Gate::before() in AppServiceProvider returns true for super-admins,
     *     short-circuiting the policy.  Non-super-admins would reach
     *     TenantPolicy::delete() → false → 403.  Because Gate 1 already
     *     blocked them, Gate 2 is a defence-in-depth backstop.
     *
     *   Gate 3 — abort_unless() explicit check inside this method
     *     The final in-code guard.  Catches any edge case where a future
     *     middleware or policy refactor inadvertently widens access.  This
     *     check is intentionally duplicative — it is the last line of defence.
     *
     * Blast-radius note: deleting a tenant drops its PostgreSQL database,
     * all EDMS data, and all domain registrations.  This is irrecoverable.
     * The UI enforces a typed-name confirmation dialog before submission.
     */
    public function destroy(Tenant $tenant): RedirectResponse
    {
        // Gate 3 — final explicit super-admin assertion (belt-and-suspenders).
        abort_unless(
            auth()->user()?->isSuperAdmin(),
            403,
            'Only the platform super-administrator may delete tenants.'
        );

        $name = $tenant->organization_name;

        // Stancl/tenancy fires TenantDeleted → DeleteDatabase job.
        // All domains are cascade-deleted by the domains table FK.
        $tenant->delete();

        return redirect()
            ->route('tenants.index')
            ->with('success', "Tenant \"{$name}\" and its database have been permanently deleted.");
    }

    // ── Status Transition ─────────────────────────────────────────────────────

    public function transitionStatus(TransitionTenantStatusRequest $request, Tenant $tenant): RedirectResponse
    {
        $this->authorize('transitionStatus', $tenant);

        $target = TenantStatus::from($request->validated()['status']);
        $reason = $request->validated()['reason'] ?? null;

        $tenant->transitionStatus($target, $reason);

        return redirect()
            ->route('tenants.show', $tenant)
            ->with('success', "Tenant {$target->incomingActionLabel()} successfully.");
    }

    // ── Domain Management ─────────────────────────────────────────────────────

    public function addDomain(Request $request, Tenant $tenant): RedirectResponse
    {
        $validated = $request->validate([
            'domain' => [
                'required', 'string', 'max:255',
                'regex:/^[a-z0-9]([a-z0-9\-]{0,61}[a-z0-9])?(\.[a-z0-9\-]{2,})+$/',
                'unique:domains,domain',
            ],
        ]);

        $this->authorize('addDomain', $tenant);

        $tenant->domains()->create(['domain' => $validated['domain']]);

        return redirect()
            ->route('tenants.show', $tenant)
            ->with('success', "Domain {$validated['domain']} added.");
    }

    public function removeDomain(Request $request, Tenant $tenant): RedirectResponse
    {
        $validated = $request->validate([
            'domain_id' => ['required', 'integer', 'exists:domains,id'],
        ]);

        $this->authorize('removeDomain', $tenant);

        $tenant->domains()->where('id', $validated['domain_id'])->delete();

        return redirect()
            ->route('tenants.show', $tenant)
            ->with('success', 'Domain removed.');
    }
}
